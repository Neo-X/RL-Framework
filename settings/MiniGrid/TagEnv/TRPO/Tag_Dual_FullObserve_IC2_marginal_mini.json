{
	"comment__": "Type of model/network to use for the actor and critic",
"model_type": "model.DeepNNKerasAdaptive.DeepNNKerasAdaptive",
    "comment__": "Learning algorithm to use",
"agent_name": "algorithm.TRPO_KERAS.TRPO_KERAS",
    "comment__": "Folder to store the training data in.",
"data_folder": "TagEnvPartiallyObserved-1particle-flatobs-dualstate-16x16-v0/IC2_marginal_mini_14",
	"comment": "initial probability of selecting a random action",
"epsilon": 1.0, 
	"comment": "initial probability of selecting a discrete random action",
"omega": 0.00,
    "comment__": "Batch size used for learning",
"batch_size": "all",
    "comment__": "Learning rate for the actor/policy",
"learning_rate": 0.0001,
    "comment__": "Config file for the simulator",
"sim_config_file": "TagEnvPartiallyObserved-1particle-flatobs-dualstate-16x16-v0",
    "comment__": "Exploration distance use when randomly generating new actions",
"exploration_rate": 0.1,
    "comment__": "Number of rounds to perform before termination",
"rounds": 250,
    "comment__": "Number of epochs to perform per round",
"epochs": 4,
    "comment__": "Number of epoch/episode to evaluate the policy over",
"eval_epochs": 16,
    "comment__": "Discount factor used during learning",
"discount_factor": 0.95,
    "comment__": "Should the training be plotted during learning",
"visualize_learning": true,
    "comment__": "Whether or not to save the plotted data while learning",
"save_trainData": true,
    "comment__": "Whether or not to train a forward dynamics model as well",
"train_forward_dynamics": true,
    "comment__": "Bounds used for scaling rewards for networks",
"reward_bounds": [[0.0],[50000.0]],
    "comment__": "Max length of the Experience memory",
"experience_length": 10000,
    "comment__": "Possible state bounds to be used for scaling states for networks",
"state_bounds": [[-2, -2, -2, -2, -2, -2, -2, -2],
				  [2,  2,  2,  2,  2,  2,  2,  2]],
        "comment__": "Action scaling values to be used to scale values for the network",				     
"action_bounds": "ask_env",
    "comment__": "Set of discrete actions that can be sampled from",				     
"discrete_actions": [[-0.92, 2.8],
                    [0.02, 3.0],
                    [0.3, 4.5],
                    [-0.4, 4.2],
                    [0.8, 4.9],
                    [-0.7, 3.0], 
                    [0.7, 4.6],
                    [-0.5, 2.6],
                    [-0.2, 3.6]],
    "comment__": "Is action space continuous or discrete?",
"action_space_continuous":true,
    "comment__": "Should the method train on the validation set only",
"train_on_validation_set":false,
    "comment__": "Name of the type of simulator to use",
"environment_type": "open_AI_Gym",
    "comment__": "Model type to use for the forward dynamics model",
"forward_dynamics_predictor": "network",
    "comment__": "How often to update the training data and plots wrt # of rounds",
"plotting_update_freq_num_rounds": 5,
    "comment__": "How often to save the training data and plotting data",
"saving_update_freq_num_rounds": 5,
    "comment__": "Number of treads that can be run in parallel during training",
"num_available_threads": 4,
    "comment__": "Length of the queues used to pass simulation data between the simulation workers and the learning agent(s).",
"queue_size_limit": 10,
    "comment__": "Number of actions performed between training updates",
"sim_action_per_training_update": 8,
    "comment__": "Method used for action exploration [gaussian_random|OrnsteinUhlenbeck]",
"exploration_method": "gaussian_network",
    "comment__": "Regularization weight for the policy network",
"regularization_weight": 0.000001,
    "comment__": "Some parameter for rmsprop stocastic gradient optimization method.",
"rho": 0.95,
    "comment__": "Some paraameter for rmsprop stocastic gradient optimization method.",
"rms_epsilon": 0.000001,
    "comment__": "Number of training updates before the target network is updated",
"steps_until_target_network_update": 1000000000,
    "comment__": "Initial factor epsilon in multiplied by (This value will slowly be reduced during training)",
"epsilon_annealing": 0.8,
    "comment__": "Different ways of calculating the scaling method used normalize the input and outputs of the network from the bootstrapping samples. minmax, input and output are -mean/max-min. variance, input and output are -mean/(std*2), given, use the bounds provided in this file",
"state_normalization": "adaptive",
    "comment__": "load a pretrained model for the controller",
"load_saved_model": false,
	"comment__": "Number of updates the critic should perform per actor update",
"critic_updates_per_actor_update": 32,
    "comment__": "weather or not to clamp actions to stay inside the action boundaries",
"clamp_actions_to_stay_inside_bounds": false,
    "comment__": "Number of initial actions to sample before calculating input/output scaling and starting to train.",
"bootstrap_samples": 20000,
    "comment__": "What method to use to select actions during bootstrapping",
"bootsrap_with_discrete_policy": true,
    "comment__": "That max number of action that can be take before the end of an episode/epoch",
"max_epoch_length": 64,
    "comment__": "The number of training updates to perform for every action that is simulated",
"training_updates_per_sim_action": 1,
    "comment__": "Network type to use for the forward dynamics model",
"forward_dynamics_model_type": "model.FDNNKerasAdaptive.FDNNKerasAdaptive",
    "comment__": "Whether or not to save the Experience memory after bootstrapping",
"save_experience_memory": false,
    "comment__": "Whether or not to train the policy and critic?",
"train_rl_learning": true,
    "comment__": "Learning rate for the forward dynamics model",
"fd_learning_rate": 0.0002,
    "comment__": "Whether or not to train the policy. Used for debugging",
"train_actor": true,
    "comment__": "Plot the terms for the critic as well (regularization and td error)",
"debug_critic": false,
    "comment__": "critic regularization weight",
"critic_regularization_weight": 0.00001,
    "comment__": "Critic learning rate",
"critic_learning_rate": 0.001,
    "comment__": "During evaluation plot of value function",
"visualize_expected_value": false,
    "comment__": "Initial tempurature for annealing of e-greedy exploration",
"initial_temperature": 1.0,
    "comment__": "epsilon lower limit",
"min_epsilon": 0.05,
	"comment__": "visualize the loss and regularization cost of the actor. Warning: might use a lot of memory",
"debug_actor": true,
	"comment__": "float type to use, if for example you want to train on the GPU use float32",
"float_type": "float32",
	"comment__": "What processor type to perform the training on [cpu|gpu]",
"training_processor_type": "cpu",
	"comment__": "optimizer is the type of optimization algorithm to use",
"optimizer": "adam",
	"comment__": "Whether or not to train the value function some output from the forward dynamics",
"train_critic_on_fd_output": false,
	"comment__": "Controls the level of information that is printed to the terminal",
"print_level": "train",
	"comment__": "print level descriptions",
"print_levels": {
		"debug": 1,
		"train": 0,
		"hyper_train": -1,
		"testing_sim": -2
		},
	"comment__": "Random seed value for the simulation to use",
"random_seed": 1234,
	"comment__": "KL divergence threshold between policy updates",
"kl_divergence_threshold": 0.1,
	"comment__": "Makes a few changes to the flow of control in order for things to be on policy [true|fast]",
"on_policy": true,
	"comment__": "Whether or not to use a stochastic policy, This adds more outputs to the network and changes the way actions are sampled",
"use_stochastic_policy": false,
	"comment__": "Whether or  not to train the critic at all. Usually used for debugging",
"train_critic": true,
	"comment__": "What type of regularization to use",
"regularization_type": "kl",
	"comment__": "Whether or not to collects tuples in batches, this can be good for multi-threading or computing furture discounted reward",
"collect_tuples_in_batches":false,
	"comment__": "Whether or not the controller should be reset to a new epoch when a fall (fallen into some kind of non-recoverable state) has occured",
"reset_on_fall": true,
	"comment__": "Whether a model of the reward r <- R(s,a) should be trained",
"train_reward_predictor": true,
    "comment__": "Whether or not the actor buffer should be fixed to process batches of a certain size",
"fix_actor_batch_size": true,
	"comment__": "Use generalized advantage estimation",
"use_GAE": true,
	"comment__": "generalized advantage estimation lambda in [0,1], when =0, this is just a one step return (lots of bias), when =1, use only data no variance reduction",
"GAE_lambda": 0.95,
	"comment__": "Whether or not to clear the experience memory after each update is done, for pure on policy methods",
"clear_exp_mem_on_poli": true,
	"comment__": "Disable scaling for inputs and outputs of networks",
"disable_parameter_scaling": false,
	"comment__": "std entropy weight to help encourage exploration",
"std_entropy_weight": 0.01,
	"comment__": "policy loss function weight, to help balance policy loss vs value function loss",
"policy_loss_weight": 1.0,
	"comment__": "number of on policy rollouts to perform per epoch",
"num_on_policy_rollouts": 32,
	"comment__": "Don't weight policy updates wrt the advantage of the action",
"dont_use_advantage": false,
	"comment__": "Only use exploratory actions to update the policy",
"only_use_exp_actions_for_poli_updates": true,
	"comment__": "Load a saved and pre-trained forward dynamics model",
"load_saved_fd_model": false,
	"comment__": "Normalize the advantage used for gradient calculations wrt the discount factor and scale of reward",
"normalize_advantage": true,
	"comment__": "use a special annealing schedule that will being at 1 and end at 0",
"annealing_schedule": "linear",
	"comment__": "Use the annealing schedule in on policy learning",
"anneal_on_policy": true,
	"comment__": "Use json network description",
"network_description_type": "json",
	"comment__": "A list describing the size of the layers for the NN",
"critic_network_layer_sizes": [ 
							{"layer_type": "Dense", "units": 64, "use_bias": true},
							{"layer_type": "activation", "activation_type": "leaky_rectify" }
							],
	"comment__": "A list describing the size of the layers for the NN",
"policy_network_layer_sizes": [ 
							{"layer_type": "Dense", "units": 64, "use_bias": true},
							{"layer_type": "activation", "activation_type": "leaky_rectify" }
							],
	"comment__": "Activation function to use for the std part of the policy",
"_last_std_policy_layer_activation_type": "sigmoid",
	"comment__": "last policy type of activation to use",
"last_policy_layer_activation_type": "linear",
	"comment__": "Use a different off-policy experience memory for the fd learning",
"keep_seperate_fd_exp_buffer": true,
	"comment__": "Batch size for the value function network",
"value_function_batch_size": 64,
	"comment__": "Additional on-policy training updates",
"additional_on_policy_training_updates": 1,
	"comment__": "Performs MBAE random sampling at the level of episodes instead of transitions",
"perform_mbae_episode_sampling": false,
	"comment__": "Using a single network for all functions",
"use_single_network": false,
	"comment__": "Anneal the std of the policy as well",
"anneal_policy_std": false,
	"comment__": "anneal the probability of performing explorative actions, set to >= 1.0 to perform only exploration actions",
"anneal_exploration": 1.0,
	"comment__": "If true the simulation will terminate after an early termination or when max time steps is reached, otherwise max_time_steps sample are collected",
"sample_single_trajectories": true,
	"comment__": "Network settings",
"network_settings": {
		"comment__": "Whether or not the network should include pooling layers between convolutions.",
	"perform_convolution_pooling": false,
		"comment__": "Change where the network splits for a single network model",
	"split_single_net_earlier": false,
		"comment__": "Use CoordConv convolutional layers.",
	"use_coordconv_layers": true
},
	"comment__": "Run some initial training steps to pretrain the critic before starting policy training",
"pretrain_critic": 0,
	"comment__": "Policy distribution change factor, if beyond this updates are not performed",
"ppo_et_factor": 1.1,
	"comment__": "higher level controller timestep",
"hlc_timestep": 1,
	"comment__": "Which backend to use for keras [theano|tensorflow]",
"learning_backend": "tensorflow",
	"comment__": "Data ordering format for convolutions",
"image_data_format": "channels_last",
	"comment__": "Size and shape of terrain",
"terrain_shape": [64,64,3],
    "comment__": "Number of terrain features for which convolutinoal filters should be used",
"num_terrain_features": 12288,
	"comment__": "specify the learning algorithm to use for the fd model",
"fd_algorithm" : "algorithm.SLACModel.SLACModel",
	"comment__": "A list describing the size of the layers for the NN",
"fd_network_layer_sizes": [ 
							{"layer_type": "Reshape", "target_shape": [16,16,3]},
							{"layer_type": "GaussianNoise", "stddev": 0.05},
							{"layer_type": "conv2d", "filters": 8, "kernel_size": [3,3], "strides": [2,2], "use_bias": false, "padding": "same"},
							{"layer_type": "BatchNormalization"},
							{"layer_type": "activation", "activation_type": "leaky_rectify" },
							{"layer_type": "Dropout", "rate": 0.2},
							{"layer_type": "conv2d", "filters": 16, "kernel_size": [2,2], "strides": [1,1], "use_bias": false, "padding": "same"},
							{"layer_type": "BatchNormalization"},
							{"layer_type": "activation", "activation_type": "leaky_rectify" },
							{"layer_type": "Dropout", "rate": 0.2},
							{"layer_type": "Flatten"},
							{"layer_type": "Dense", "units": 64, "use_bias": true},
							{"layer_type": "activation", "activation_type": "leaky_rectify" }
							],
	"comment__": "A list describing the size of the layers for the NN",
"reward_network_layer_sizes": [
							{"layer_type": "Input", "shape": ["none", "none", 11], "flag": "action"},
							{"layer_type": "Input", "shape": ["none", "none", 32]},
							{"layer_type": "integrate_actor_part"},
							{"layer_type": "LayerNormalization"},
							{"layer_type": "Dense", "units": 32, "use_bias": true}
							],
	"comment__": "last policy type of activation to use",
"last_fd_layer_activation_type": "sigmoid",
	"comment__": "The number of fd network to be done per actor update.",
"fd_updates_per_actor_update": 2.0,
	"comment__": "Leave off the final layer of the network that would result in a state sized output",
"fd_network_leave_off_end": true,
	"comment__": "Use learned reward function",
"use_learned_reward_function": "ic2_marginal",
	"comment__": "Mix different state description types, used for debugging visual imitation learning",
"use_dual_state_representations": true,
	"comment__": "Size and shape of terrain",
"fd_terrain_shape": [16,16,3],
    "comment__": "Number of terrain features for which convolutinoal filters should be used",
"fd_num_terrain_features": 768,
	"comment__": "replace the viz state in the next state with the state from the imitation agent",
"replace_next_state_with_imitation_viz_state": false,
	"comment__": "Just train the fd model in an LSTM fashion",
"train_LSTM_FD": false,
	"comment__": "Use a stateful LSTM",
"train_LSTM_FD_stateful": false,
	"comment__": "batch size for lstm fd models",
"lstm_batch_size": [32, 32],
	"comment__": "experience size for fd network",
"fd_experience_length": 5000,
	"comment__": "Just train the fd model in an LSTM fashion",
"train_LSTM_Reward": true,
	"comment__": "Leave off the final layer of the reward network that would result in a state sized output",
"reward_network_leave_off_end": true,
	"comment__": "Episode simulation time out",
"simulation_timeout": 1800,
	"comment__": "Include some randomly sized sequences when training lstms",
"use_random_sequence_length_for_lstm": false,
	"comment__": "Use a sparse sequence based reward",
"use_sparse_sequence_based_reward": false,
	"comment__": "Make earlier and shorter lstm training batches more probable.",
"shorter_smaller_rnn_batches": 8,
	"comment__": "When the agent falls give it a bad reward 1/(1-discount_fator)",
"use_fall_reward_shaping": false,
	"comment__": "Run some initial training steps to pretrain the fd before starting policy training",
"pretrain_fd": 100,
	"comment__": "The shortest sequence the RNN network will be trained on",
"min_sequece_length": 3,
	"comment__": "Train the fd network as well",
"train_lstm_fd_and_reward_and_decoder_together": true,
	"comment__": "A list describing the size of the layers for the NN",
"decoder_network_layer_sizes": [ 
								{"layer_type": "Input", "shape": ["none", 32], "flag": "fd_input"},
								{"layer_type": "Dense", "units": 256, "use_bias": false},
								{"layer_type": "BatchNormalization"},
								{"layer_type": "activation", "activation_type": "leaky_rectify" },
								{"layer_type": "Dropout", "rate": 0.2},
								{"layer_type": "Reshape", "target_shape": [4, 4, 16]},
								{"layer_type": "deconv2d", "filters": 8, "kernel_size": [4,4], "strides": [2,2], "use_bias": false, "padding": "same"},
								{"layer_type": "coordconv2d"},
								{"layer_type": "BatchNormalization"},
								{"layer_type": "activation", "activation_type": "leaky_rectify" },
								{"layer_type": "Dropout", "rate": 0.2},
								{"layer_type": "deconv2d", "filters": 1, "kernel_size": [6,6], "strides": [2,2], "use_bias": false, "padding": "same"},
								{"layer_type": "BatchNormalization"},
								{"layer_type": "activation", "activation_type": "linear" },
								{"layer_type": "Dropout", "rate": 0.2},
								{"layer_type": "Flatten"}
							],
	"comment__": "A list describing the size of the layers for the NN",
"decoder_network_layer_sizes2": [
							{"layer_type": "Input", "shape": ["none", "none", 11], "flag": "action"},
							{"layer_type": "Input", "slice_label": "action"},
							{"layer_type": "LayerNormalization"},
							{"layer_type": "Dense", "units": 256, "use_bias": true}
							],
	"comment__": "The encoding vector size used for the fd models",
"encoding_vector_size": 32,
"rnn_updates" : 64,
	"comment__": "Flag to indicate to SLAC to use a smaller image and conv net size",
"slac_use_small_imgs": true,
	"comment__": "Recompute the rewards using the learning reward model.",
"refresh_rewards": true,
"return_rnn_sequence": true,
"ic2_marginal_window_size": 50000,
"experiment_logging": {
	"use_comet": true, 
	"project_name": "ic2"
	}	
}